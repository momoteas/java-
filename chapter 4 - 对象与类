> 很多程序员用UML（unified modeling language）绘制描述类之间关系的类图；
> 在Java中,任何对象变量的值都是对存储在另外一处的一个对象的引用。new操作符的返回值也是一个引用；
> 封装：（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为结合在一个包中，并对对象的使用者隐藏了数据
  的实现方式。对象中的数据被称为实例域（instance field），操作数据的过程被称为方法（method）。
> 实现封装的关键在于绝对不能让类中的方法直接访问其他类的实例域,但可以访问它自己类的实例域,这一点要反复强调；

4.1.2 对象：
  > 要想使用OOP,一定要清楚对象的三个主要特性:
    • 对象的行为(behavior)—可以对对象施加哪些操作,或可以对对象施加哪些方法?
    • 对象的状态(state)—当施加那些方法时,对象如何响应?
    • 对象的标识(identity)—如何区分具有相同行为与状态的不同对象?
  > 对象状态的改变必须通过调用方法实现；
  
4.1.3 类之间的关系：
  > 在类之间,最常见的关系有
    • 依赖(“uses-a”)
    • 聚合(“has-a”)
    • 继承(“is-a”)
    
4.2.1 对象与对象变量：
  > 要想使用对象,就必须首先构造对象,并指定其初始状态。然后,对对象施加方法；
  > 在Java程序设计语言中,使用构造器(constructor)构造新实例。构造器是一种特殊的方法,用来构造并初始化对象。
  > 构造器的名字应该与类名相同。因此Date类的构造器名为Date。要想构造一个Date对象,需要在构造器前面加上new操作符,如下所示:
      new Date( )
  > 必须首先初始化变量deadline。这里有两个选择。当然可以用新构造的对象初始化这个变量:
      deadline = new Date( );
    或者让这个变量引用一个已存在的对象:
      deadline = birthday;
      
4.2.3 更改器方法与访问器方法：
  > get方法与set和add方法在概念上是有区别的。get方法仅仅查看并返回对象的状态,而set和add方法却对对象的状态进行修改。对实例域做出修改的方法被称为
    更改器方法,仅访问实例域而不加修改的方法被称为访问器方法;
  > 通常的习惯是在访问器方法名前面加上前缀get,在更改器方法前面加上前缀set;
  
4.3 用户自定义类：
  > 这个类的所有方法都被标记为public。关键字public意味着任何类的任何方法都可以调用这个方法。(共有4种访问级别);
  > 关键字private确保只有Employee类自身的方法能够访问这些实例域,而其他类的方法不能够读写这些域;
  > 已经看到,构造器与类同名。在构造Employee类对象时,构造器被运行,并用于将实例域初始化为所希望的状态;
  > 构造器与其他的方法有一个重要的不同。构造器总是伴随着new操作符的执行被调用,而不能对一个已经存在的对象调用构造器来重新设置实例域。例如,
      james.Employee("James Bond", 250000, 1950, 1, 1); // ERROR
  > 本章稍后,还会更加详细地介绍有关构造器的内容。现在只需要记住:
    • 构造器与类同名。
    • 每个类可以有一个以上的构造器。 
    • 构造器可以有0个、1个或1个以上的参数。
    • 构造器没有返回值。
    • 构造器总是伴随着new操作符一同使用
  > Java构造器的工作方式与C++是一样的。但是,要记住所有的Java对象都是在堆中构造的,构造器总是伴随着new操作符一起使用;
  > 请注意,不要在构造器中定义与实例域重名的局部变量;
  > 在每一个方法中,关键字this表示隐式参数;

4.3.6 封装的优点：
  > 在有些时候,需要获取或设置实例域的值。因此,应该提供下面三项内容:
    • 一个私有的数据域。
    • 一个公有的域访问器方法。
    • 一个公有的域更改器方法。
  ? 提示:注意不要编写返回引用可变对象的访问器方法; 
  > 尽管绝大多数方法都设计为公有的,但在特殊情况下,也可能会设计为私有的。在有些时候,可能希望将一个计算代码划分成若干个独立辅助的方法。通常,
    这些辅助方法不应该成为公有接口的一部分,这是由于它们往往与当前的实现机制非常紧密,或者需要一个特别的协议以及一个特别的调用次序。这样的方
    法最好被设计为private的;
  > 在Java中,为了实现一个私有的方法,只需要将关键字public改为private即可;
  
4.3.9 final实例域：
  > 可以将实例域定义为final。构建对象时必须初始化这样的域。也就是说,必须确保在每一个构造器执行之后,这个域的值被设置,并且在后面的操作中,不
    能够再对它进行修改;
  > 例如, private final Date hiredate 仅仅意味着存储在hiredate变量中的对象引用在对象构造之后不能被改变;
  
4.4 静态域与静态方法：
  > 4.4.1 静态域:
    > 现在,每一个雇员对象都有一个自己的id域,但这个类的所有实例将共享一个nextId域。换句话说,如果有1000个Employee类的对象,则有1000个实例域id。
      但是,只有一个静态域nextId。即使没有一个雇员对象,静态域nextId也存在。它属于类,而不属于任何独立的对象。
  > 4.4.2 常量：
    > 静态变量使用得比较少,但静态常量却使用得比较多: public static final double PI = 3.1415926;
  > 4.4.3 静态方法：
    > 静态方法是不能向对象实施操作的方法。例如,Math类的pow方法就是一个静态方法。表达式 Math.pow(x, a) 计算幂x a 。它在运算的时候,不使用任何
      Math对象。换句话说,没有隐式的参数;
    > 因为静态方法不能操作对象,所以不能在静态方法中访问实例域。但是,静态方法可以访问自身类中的静态域;
    
4.5 方法参数：
  > 值调用(call by value)表示方法接收的是调用者提供的值。而引用调用(call by reference)表示方法接收的是调用者提供的变量位置;
  > Java程序设计语言使用值调用。也就是说,方法得到的是所有参数值的一个拷贝,特别是,方法不能修改传递给它的任何参数变量的内容;
  > 然而,方法参数共有两种类型:
    • 基本数据类型(数字、布尔值)。
    • 对象引用。
  > 
    
    
    










